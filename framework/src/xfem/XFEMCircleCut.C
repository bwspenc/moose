/****************************************************************/
/*               DO NOT MODIFY THIS HEADER                      */
/* MOOSE - Multiphysics Object Oriented Simulation Environment  */
/*                                                              */
/*           (c) 2010 Battelle Energy Alliance, LLC             */
/*                   ALL RIGHTS RESERVED                        */
/*                                                              */
/*          Prepared by Battelle Energy Alliance, LLC           */
/*            Under Contract No. DE-AC07-05ID14517              */
/*            With the U. S. Department of Energy               */
/*                                                              */
/*            See COPYRIGHT for full restrictions               */
/****************************************************************/

#include "XFEMCircleCut.h"

#include "MooseError.h"
#include "EFAFuncs.h"
#include "XFEMFuncs.h"

XFEMCircleCut::XFEMCircleCut(std::vector<Real> circle_nodes):
   XFEMGeometricCut3D(0.0, 0.0),
   _vertices(2, Point(0.0,0.0,0.0)),
   _radius(0.0),
   _angle(0.0)
{
   _center   = Point(circle_nodes[0], circle_nodes[1], circle_nodes[2]);
  _vertices[0]  = Point(circle_nodes[3], circle_nodes[4], circle_nodes[5]);
  _vertices[1]  = Point(circle_nodes[6], circle_nodes[7], circle_nodes[8]);

  Point ray1 = _vertices[0] - _center;
  Point ray2 = _vertices[1] - _center;

  _normal = ray1.cross(ray2);
  normalizePoint(_normal);

  Real R1 = std::sqrt(ray1.size_sq());
  Real R2 = std::sqrt(ray2.size_sq());
  if( std::abs(R1 - R2) > 1e-10 )
    mooseError("XFEMCircleCut only works for a circular cut");

   _radius = 0.5*(R1 + R2);
   _angle = std::acos( (ray1*ray2)/(R1*R2) );
}

XFEMCircleCut::~XFEMCircleCut()
{}

//BWS TODO: This is identical to the one in XFEMGeometricCut3D, but the penny crack test fails if I don't overwrite it
bool
XFEMCircleCut::intersectWithEdge(Point p1, Point p2, Point &pint)
{
  bool has_intersection = false;
  double plane_point[3] = {_center(0), _center(1), _center(2)};
  double plane_normal[3] = {_normal(0), _normal(1), _normal(2)};
  double edge_point1[3] = {p1(0), p1(1), p1(2)};
  double edge_point2[3] = {p2(0), p2(1), p2(2)};
  double cut_point[3] = {0.0,0.0,0.0};

  if(plane_normal_line_exp_int_3d(plane_point, plane_normal, edge_point1, edge_point2, cut_point) == 1) {
    Point temp_p(cut_point[0], cut_point[1], cut_point[2]);
    if( isInsideCutPlane(temp_p) && isInsideEdge(p1, p2, temp_p) )
    {
      pint = temp_p;
      has_intersection = true;
    }
  }
  return has_intersection;
}

bool XFEMCircleCut::isInsideCutPlane(Point p){
    Point ray = p - _center;
    if( std::abs(ray*_normal)<1e-15 && std::sqrt(ray.size_sq()) < _radius )
	return true;
    return false;
}

